<?php


namespace rapidPHP\library\core\server;


use Exception;
use Swoole\Atomic;
use Swoole\Server;

abstract class SwooleServer
{
    /**
     * key task_worker_num
     */
    const KEY_TASK_WORKER_NUM = 'task_worker_num';

    /**
     * ip地址
     * @var string
     */
    private $ip = '0.0.0.0';

    /**
     * 端口
     * @var int
     */
    private $port = 9501;

    /**
     * 可选设置
     * @var array
     */
    private $options = [
        //开启静态文件处理
        'enable_static_handler' => true,
        //静态文件目录
        'document_root' => ROOT_PATH,

        'enable_coroutine' => true
    ];

    /**
     * 任务无锁原子计数器
     * @var Atomic
     */
    private $taskAtomic;

    /**
     * 所有任务回调事件
     * 因为任务触发可能会很多，为了节省内存，则自行匹配数据，或者任务id
     * @var array
     */
    private $taskEvents = [];

    /**
     * 快速获取实例对象
     * @return SHttpServer
     */
    abstract public static function getInstance();

    /**
     * @return Server|\Swoole\Http\Server|\Swoole\WebSocket\Server
     */
    abstract public function getServer();

    /**
     * @return string
     */
    public function getIp(): string
    {
        return $this->ip;
    }

    /**
     * @param string $ip
     */
    public function setIp(string $ip): void
    {
        $this->ip = $ip;
    }

    /**
     * @return int
     */
    public function getPort(): int
    {
        return $this->port;
    }

    /**
     * @param int $port
     */
    public function setPort(int $port): void
    {
        $this->port = $port;
    }

    /**
     * @return array
     */
    public function getOptions(): array
    {
        return $this->options;
    }

    /**
     * @param array $options
     */
    public function setOptions(array $options): void
    {
        $this->options = array_merge($this->options, $options);
    }

    /**
     * @return Atomic
     */
    public function getTaskAtomic(): Atomic
    {
        return $this->taskAtomic;
    }

    /**
     * 添加监听
     * @param string $event
     * @param callable $callback
     */
    protected final function on(string $event, callable $callback)
    {
        $this->getServer()->on($event, $callback);
    }

    /**
     * 创建Server
     * @return $this
     */
    abstract public function create();

    /**
     * 开启web服务，只能调用一次
     */
    public function start()
    {
        if (array_key_exists(self::KEY_TASK_WORKER_NUM, $this->getOptions())) {
            $this->taskAtomic = new Atomic(0);
        }

        $this->getServer()->set($this->getOptions());

        $this->on("start", [$this, 'onStart']);

        $this->on('task', [$this, 'onTask']);

        $this->on('finish', [$this, 'onFinish']);

        $this->getServer()->start();
    }

    /**
     * 添加任务回调事件
     * @param callable $callback
     * @param null $id
     * @return int
     */
    public function addTaskListener(callable $callback, $id = null)
    {
        $id = is_null($id) ? count($this->taskEvents) : $id;

        $this->taskEvents[$id] = $callback;

        return $id;
    }

    /**
     * 移除监听任务回调事件
     * @param $id
     */
    public function removeTaskListener($id)
    {
        unset($this->taskEvents[$id]);
    }

    /**
     * 添加任务
     * @param $data
     * @throws Exception
     */
    public function addTask($data)
    {
        if ($this->getTaskAtomic() == null) $this->taskAtomic = new Atomic(0);

        $taskNum = (int)B()->getData($this->getOptions(), self::KEY_TASK_WORKER_NUM);

        if ($taskNum > 0 && $this->getTaskAtomic()->get() >= $taskNum) {
            throw new Exception('暂时不能添加任务哦!');
        }

        $taskId = $this->getServer()->task($data);

        if ($taskId === false) throw new Exception('添加任务失败!');

        $this->getTaskAtomic()->add(1);
    }

    /**
     * server开启
     * @param $server
     */
    public function onStart($server)
    {
        // TODO: Change the autogenerated stub
    }


    /**
     * 收到任务请求
     * @param Server $server
     * @param $taskId
     * @param $reactorId
     * @param $data
     */
    public function onTask($server, $taskId, $reactorId, $data)
    {
        // TODO: Change the autogenerated stub
    }

    /**
     * 任务结束
     * @param Server $server
     * @param $taskId
     * @param $data
     */
    public function onFinish($server, $taskId, $data)
    {
        $this->taskAtomic->sub(1);

        foreach ($this->taskEvents as $event) {
            call_user_func_array($event, [$server, $taskId, $data]);
        }

        // TODO: Change the autogenerated stub
    }
}